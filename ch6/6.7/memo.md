# 6.7 ポインター関連演算子のオーバーロード
C++では、算術演算や論理演算だけでなく、ポインターを扱う演算子についても他の演算子と同様にオーバーロードできます。
特に関節参照演算子(*)とアドレス演算子(&)は、それぞれ乗算演算子とビットアンド演算子と同じ記号を使用しますが、項数が異なるため同じ記号であっても問題なくオーバーロードできます。
ポインター関連演算子をオーバーロードする機会はほとんどないかもしれませんが、専用のスマートポインターを自作する際などに活躍します。
スマートポインターはdeleteし忘れを防ぐ機能や、deleteできるタイミングが難しいポインターを扱う場合にとても役にたつライブラリです。

## 6.7.1 簡単なスマートポインターの例

## 6.7.2 アロー演算子のオーバーロード
C++ではアロー演算子もオーバーロードして、よりポインターに近い操作を提供することができます。

アロー演算子は演算子の中でも少し特殊であり、必ずポインター型で返さなければならないという規則があります。

## 6.7.3 std::unique_ptr
標準ライブラリが提供するスマートポインターにはいくつか種類がありますが、基本的でよく使うスマートポインターstd::unique_ptr(<memory>ヘッダーが必要)について説明します。

std::unique_ptrはnew演算子を使って確保されたメモリ領域がメモリリークしないようにデストラクターで自動的にdelete演算子を呼び出します。
デストラクターでdeleteを呼び出すので、new演算子で確保したメモリ領域はそのstd::unique_ptrの変数のスコープと同じだけの寿命を持ちます。

ただし、無ーブコンストラクターを持っているので、寿命が尽きる前に他のstd::unique_ptrへメモリ領域の所有権を移動すると、より長い期間メモリ領域を使用する子tができます。一方、コピーコンストラクターは持っていないので二重解放の危険性はありません。

std::unique_ptrはstd::vectorと同じくテンプレート機能を使って実装されているので、管理したいメモリ領域の方をテンプレート引数として渡す必要があります。

```C++

int main() {
  {
    std::unique_ptr<A> ptr; // 空のstd::unique_ptr。

    std::cout << "関数呼び出しの前" << std::endl;

    ptr = allocate(); // allocate()が確保したメモリ領域の所有権を受け取る

    std::cout << "関数呼び出しの後" << std::endl;
  }

  std::cout << "スコープの後" << std::endl;
  // 関数呼び出しの前
  // allocate()
  // コンストラクター
  // 関数呼び出しの後
  // デストラクター
  // スコープの後
}
```
allocate()関数の中で確保されたメモリ領域は、関数呼び出しが終了してもデストラクターが呼ばれていません。関数スコープは関数呼び出しが終了した段階、つまり"関数呼び出しの後"というメッセージの前までに終了しているはずですが、メモリ領域の所有権が戻り値を返してptrに映ったのでptrが破棄される段階まで先延ばしされました。
ptrが破棄されるのはmain()関数の内側のスコープが終了したタイミングです。これは"関数呼び出しの後'というメッセージと、"スコープの後"というメッセージの間であり、実際に実行結果もそのタイミングでデストラクターが呼ばれています。

このようにして、std::unique_ptrはメモリ領域が使われている間管理します。
stdd::unique_ptrはポインター型と同じように振る舞うために、アロー演算子と関節参照演算子の両方を演算子オーバーロードしています。

```C++
class A {
public:
  void foo();
};

std::unique_ptr<A> ptr{new A{}}

ptr->foo(); // アロー演算子を使ってメンバー関数を呼び出す。

A& ref = *ptr; // 関節参照演算子を使って参照する
```

std::unique_ptr をより簡単に作るためにstd::make_unique()関数というヘルパー関数も提供されています。std::make_unique()関数は、渡された実引数を使って、動的確保とコンストラクター呼び出しを一気に行います。

```C++
class A {
public: 
  explicit A(int a, float b);
};

// std::unique_ptr<A>{new A(0, 1.0f)} を返す。
auto ptr std::make_unique<A>(0, 1.0f);
```

## 6.7.4 アドレス演算子のオーバーロード
アドレス演算子はオブジェクトのポインターを取得する演算子ですが、あまり無闇にこの演算子をオーバーロードしてしまうと、本当にそのオブジェクト本来のアドレスが欲しい場合に困ったことになりかねません。
「一応オーバーロードができる」ということだけ覚えておいて、基本用いず、デバッグようにメッセージを出力した上でthisポインターを返す程度にしておくのが良いでしょう。
