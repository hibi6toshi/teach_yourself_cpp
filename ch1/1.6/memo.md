# 配列
配列の宣言
```
type array-name[length];

type array-name[length] = { initial-values... };

type array-name[] = { initial-values... };
```

配列は長さを指定する必要があり、長さ分だけ同じ型の要素がメモリ上に順番に並ぶことになります。長さはプログラムを書くを機に決まっていなければならず、後から長くすることもできません。（短くすることもできないが、配列の後ろを使わないことで実現できます。）
3番目の構文は配列なのに長さがなく、初期化リストを使って初期化している。このような婆愛、初期化リストに書かれた初期値の数をコンパイラーが暗黙的に配列の長さとして扱う。

この二つの構文はどちらも同じ結果となる。
```
int array[5] = { 1, 2, 3, 4, 5};

int array[] = { 1, 2, 3, 4, 5};
```
　
- これらの使い分け
長さを指定しない場合は、初期化リストの長さが配列の長さとなるため、初期化リストで渡す初期値の数を変えることで配列の長さも変えることができます。

一方、配列の長さを指定した場合には次の３通りが考えられます。

- 指定した長さと、初期化リストの長さが同じ場合。 
- 指定した長さが、初期化リストの長さより長い場合。
- 指定した長さが、初期化リストの長さより短い場合。

2番目の場合は、残りの足りない部分は0で初期化される。
3番目の場合は、エラーとなります。

配列は通常の変数と違って、他の配列をそのまま使った初期化や代入ができないことに注意しなければなりません。
もし配列の中身を他の配列にコピーしたい場合は、各要素をコピーする必要がある。
```
int source[] = { 0, 1, 2, 3, 4};
int dest1[] = source; // エラー。配列を使って初期化はできない。

dest1 = source; // エラー。配列の代入もできない。

// OK 初期化リストを使って各要素を個別に初期化する
int dest2[5] = { source[0], source[1], source[2], source[3], source[4]};

// OK 各要素を個別に代入
dest2[0] = source[0];
dest2[1] = source[1];
dest2[2] = source[2];
dest2[3] = source[3];
dest2[4] = source[4];
```

# 配列のサイズ
変数が必要とするメモリのサイズはsizeof演算子を使って取得しましたが、配列が必要とするサイズもsizeof演算子を使うことで取得できます。このときsizeof演算子が返す値は配列全体が必要とするバイト数となります。

```
#include <iostream>
int main() {
  int array[10] = {};
  std::cout << "sizeof(array):" << sizeof(array) << std::endl;
}

// sizeof(array): 40
```

配列の各要素はメモリ上で隙間なく隣り合っているので、配列の長さ（要素数）を知りたいときには、配列全体のサイズを要素の型で割ることで得られます。

## 文字列
文字リテラルと文字列リテラルは異なるものでしたが、変数として格納したときには「char型の変数1つ」か「char型の配列」かという違いになります。

文字列は最後に必ず**ヌル文字列(null charactor: "\0")**を入れる決まりになっていて、このヌル文字で文字列が終わったことを表します。このようにヌル文字で終端された文字列のことを**ヌル終端文字列**と呼びます。
ヌル文字は数字の0と等しいことが決まっているので、ブレースを使った初期化をしていれば明示的に代入しなくても良い