# 7.4 仮想関数の詳細

## 7.4.1 仮想関数（再び）
仮想関数は、基底クラスの動作そのものを派生クラスから変更する機能です。常に派生クラスだけを使うような状況ではあまり使われませんが、関数が基底クラスのポインターや参照しか受け取らないよう場面で動作を変えるために使われます。

基底クラスしか受け取らないような関数であっても、仮想関数の「規定クラスの動作を変えることができる」機能を使うことで、基底クラスに見せかけつつ、派生クラスでオーバーライドしたメンバー関数の呼び出しを行わせるといったことが可能になります。

## 7.4.2 型指定して基底クラスのメンバー関数を呼び出す
仮想関数とは規定クラスの動作を変更する機能です。多くの場合、基底クラスの動作を踏襲しつつ、さらにそこに機能を追加するために使われます。

```C++
class Derived : public Base {
public:
  void method() override;
};

void Derived::method() {
  std::cout << "Derived::method()" << std::endl;
  Base* base = this; // 基底クラスへのポインターを取得
  base->method(); // 基底クラスのメンバーを呼んでいるつもり
}

int main() {
  Derived derived;
  derived.method(); // オーバーライドしたメンバー関数の呼び出し。
  // ->
  // Derived::method()
  // Derived::method()
  // Derived::method()
  // Derived::method()
  // ...
}
```
仮想関数とは、基底クラスのポインターや参照から派生クラスのメンバー関数を呼ぶ機能でした。
そのため、Base::method()メンバー関数を呼び出しているつもりでも、実は自分自身をもう一度呼び出す**再起呼び出し**となってしまします。

基底クラスのメンバー関数を正しく呼び出すためには、関数呼び出しの際にどのクラスのメンバー関数を呼び出すのか型を指定します。
上記の例の場合は、型指定した呼び出しはBase::method() メンバー関数となります。

## 7.4.3 非公開メンバーの仮想関数
仮想関数が非公開メンバーであった場合はどうなるか
非公開メンバーには派生クラスからであったもアクセスすることはできないため、基底クラスの実装を呼び出すことはできない。
オーバーライドすることは可能。

非公開メンバーであってもオーバーライドだけはでき、正しく派生クラスでオーバーライドした関数が呼ばれます。
しかし、基底クラスのメンバーは非公開であることに変わりないのでデフォルトの動作などを引き継ぐことはできません。

仮想関数は本当に動作に違いを出したいほんの一部だけで使い、残りの共通部分は通常の公開メンバー関数として基底クラスに実装されることが多いからです。
