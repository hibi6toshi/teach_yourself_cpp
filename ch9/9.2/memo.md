# 9.2 クラステンプレート
テンプレートの基本的な使われ方のもう1つは**クラステンプレート**です。これは関数テンプレートよりも複雑な一方、さまざまな用途に使用される機能です。
クラスとは元々データとそのデータの操作を1箇所にまとめたものでした。これを、テンプレートにするということは、データ・操作の両方のコピーがテンプレート引数ごとに作られることになります。クラステンプレートでも、実際の型を渡してコピーを作ることを実体化と言います。クラステンプレートの実体化と、クラスのインスタンスを作る実体化は異なりますが、同じ言葉を使います。

クラステンプレートもあkん数テンプレートのときと同じく、機能としてはクラステンプレートという名前ですが、特定のクラステンプレートを指し示すときには、「std::basic_iostreamテンプレートクラス」などと呼びます。

## 9.2.1 メンバー関数を持たない場合
まずメンバー関数を持たないクラスをテンプレートにするには以下のようにします。
```C++ 
template <typename template-parameter1, typename template-parameter2...>
class class-name {
  class-body...
};

class-name<template-argument1, template-argument2...> variable;
```

テンプレートパラメーターはクラス本体のどこでも使用できます。

## 9.2.2 メンバー関数を持つ場合
クラステンプレートがメンバー関数を持つ場合、クラスの定義の中でメンバー関数の定義まで記述して仕舞えばそれほどややこしくないのですが、定義を別にしたい場合には、単なるクラスのメンバー関数がテンプレートだったとき構文と少し似たように書く必要があります。
```C++
template <typename T>
class S {
public:
  // メンバー関数の定義をクラス定義の中で書く場合にはそれほど難しくない
  void foo() {
    ...
  }

  void bar(); // 本体の定義を分ける場合
}

// クラステンプレートSのメンバー関数定義
template <typename T>
void S<T>::bar() {　
  ...
}
```

テンプレートパラメーターがクラスにつくのか、メンバー関数に付くのかで定義の仕方が少し異なるだけなので、初めのうちはよく見ないとクラスがテンプレートなのか、関数がテンプレートなのかを見間違えてしまいます。

そのため、慣れるまでは、どちらのテンプレートであってもクラス定義の中に書いてしまうことで、そういった混乱を防ぐことができます。クラス関数が大きくなったら、分けることを考えても良いでしょう。
ただしこのときに分けたメンバー間巣の定義は、ヘッダーファイルに記載しておかなければコンパイラーが実体化するときにどう実体化したら良いのかわからなくなってしまいます。
これらを組み合わせることで、クラスのテンプレートのメンバー関数を関数テンプレートすることも可能です。
```C++
template <typename T>
class S {
public: 
  // クラス定義の中でメンバー関数テンプレートも書いてしまう場合
  template <typename U>
  void foo(U value) {
    ...
  }

  // 宣言と定義を分けて書く場合
  template <typename U>
  void bar(U value);
};

template <typename T> // クラステンプレートのためのtemplate
template <typename U> // メンバー関数テンプレートのためのtemplate
void S<T>::bar(U value) {
  ...
}
```
ここでは2行に分けてtemplateを書いていますが、これを1つにまとめたり上下を入れ替えたりすることはできません。
