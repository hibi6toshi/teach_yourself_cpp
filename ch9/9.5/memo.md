# 9.5 型推論
**型推論**とは値や変数、式の型を使ってコンパイラーが変数や引数の型を決定する機能です。
C++では式の結果から決定される型をautoや関数テンプレートのテンプレート引数として利用するために使います。

## 9.5.1 autoを使った型推論
**auto**を使った型推論をすると、複雑な型をいちいち書かずに済むためプログラムが簡潔になり見通しが良くなる上、値や式に変更があった型を書き直す手間が減ります。
ネストした型が使われているような場面で、型名を間違えたり間違った型を使ってしまったりなど些細なミスを防ぐのに特に威力を発揮します。
autoでの型推論はこれまで変数宣言のために使ってきたが、関数の戻り値も型推論するようにできます。

テンプレートパラメーターに依存した型は特に長くなりますが、戻り値の型をテンプレートパラメーターだけで記述するのはとても困難です。

## 9.5.2 関数テンプレート呼び出し時の型推論
これまでは関数テンプレートの呼び出しの際にテンプレート引数を全て指定した上で呼び出していましたが、型推論に任せると、通常の関数呼び出しのように何も指定せず呼び出せるようになります。
簡単な関数テンプレートの呼び出しであれば全て型推論に任せてしまうのが簡潔で良いでしょう。

## 9.5.3 テンプレートパラメーターの一部を型推論する
テンプレートパラメーターの全てで型推論しなければならないわけではありません。テンプレートを一部だけ明示的に指定して、残りを型推論に任せるということもできます。ただし、指定できるのはテンプレートパラメーターの先頭から順番になります。
関数テンプレートを定義する際に、指定できた方が便利なテンプレートパラメーターを前の方に、推論させた方が便利なテンプレートパラメーターを後ろにすると使いやすい関数テンプレートになります。

## 9.5.4 引数からクラステンプレートのパラメーターを推論する
仮引数がテンプレートパラメーターを使ったクラステンプレートになっている場合、実引数からテンプレートパラメーターを推論することもできます。クラステンプレート
を値で受け取る場合だけでなく、参照やポインターを受け取る場合でも推論が可能です。

## 9.5.5 型推論の制限
型推論にもいくつか制限があります。
まずautoで変数を宣言する場合には初期値を与えないと型推論できません。

1つの文で複数の変数を宣言する場合には、全てで同じ型に推論されなければなりません。1つの推論結果が他の変数にも適用されるということはありません。

関数テンプレートにおいては、引数になっていないテンプレートパラメーターは推論ができません。関数内部でしか使われないテンプレートパラメーターや、
戻り値でしか指定されないテンプレートパラメーターは、必ず呼び出し時に指定しなければなりません。
```C++
// RとABは引数に使われていないテンプレートパラメーター
template <typename R, typename AB, typename A, typename B, typename C>
R fused_multiply_add(A a, B b, C b) {
  AB ab = a * b;
  return static_cast<R>(ab + c);
}

// エラー。戻り値の使われ方から遡ってRの推論はできず、また引数にないABは推論できない
float r = fused_multiply_add(1.23455, 2, 1.23456f);
```
ネストした型の一部としてテンプレートパラメーターを使っている場合には推論できません。
```C++
template<typename T>>
auto addressof(typename std::vector<t>::reference r) { // 引数はネストした型
  return &r;
}

std::vector<int> v;
addressof(v[0]); // Tをint型に推論してほしい
```

ネストした型は、クラステンプレートの中で様々な処理がされた後にその型が決まります。
そのためネストした型からさかのぼって、そのクラステンプレートのテンプレート引数を推論することはできません。
ただし、他の引数から推論できる場合や、ネストしていない場合には推論できます。
```C++
template <typename T>
void assign(typename std::vector<T>iterator i, T value) {
  *i = value;
};

std::vector<int> v{10, 20, 30};
// v.begin()だけから推論はできないが、第2引数を使って推論して、
// そのTを使って第1引数の方を求める
assign(v.begin(), 40);
```