# 初期値を受け取るコンストラクタ
## コンストラクターは複数用意できる
コンストラクターの働きは1つはメンバー変数の初期化です。
その際、常に同じ初期値で初期化するのであれば前節で説明したコンストラクターだけがあれば問題ありませんが実際はさまざまな初期値を使うことのほうが多いでしょう。
コンストラクターは通常の関数と同様に引数を受け取ることができるため、引数を使って初期化を行うことができます。また、コンストラクターもオーバーロードできるので、ユーザーが使いやすいように複数のコンストラクターを用意することも可能です。

```
class class-name {
  public:
   class-name(parameters...); // 引数を受け取るコンストラクター
   ...
};

// インスタンスの生成とコンストラクター呼び出し
class-name variable-name(arguments...);
```

ただし、このとき注意しなければならないのは、引数を受け取るコンストラクターを1つでも定義してしまうと、コンパイラーが自動で生成するデフォルトコンストラクターがなくなってしまうということです。
**デフォルトコンストラクター**は引数がないコンストラクターのことで、通常はコンパイラーが自動的に何もしないデフォルトコンストラクターを定義します。しかしプログラマーがデフォルトコンストラクターを定義した場合にはそちらが使われます。
そのため、プログラマーがデフォルトコンストラクターを別途定義するか、インスタンスを作る際に必ず引数を渡す必要があります。

## 委譲コンストラクター
さらにコンストラクターで行う処理は「初期値が少し異なるだけで手順は同じ」というケースが多々ありあす。通常の関数であれば、関数の中から他のオーバーロードを呼ぶことが簡単にできるため、コンストラクターのそのようにできるかと思うかもしれませんが、コンストラクターは直接呼び出せない（オブジェクト生成時にしか呼び出せない）ので、他のコンストラクターを呼び出すための専用の方法が用意されています。これを**委譲コンストラクター**と呼びます。
委譲さきのコンストラクターが呼ばれてから、移譲元のコンストラクターの処理が続きます。委譲コンストラクターは処理の大部分を委譲先に任せます。
特にメンバー変数の初期化は委譲先でしかできず、移譲元のコンストラクターではメンバー変数の初期化はできません。

```C++
class class-name {
  public:
   class-name(parameters...); // 移譲元コンストラクターの宣言
   ...
};

class-name::class-name(parameters...) // 移譲元コンストラクターの定義
      : class-name(arguments...) // 委譲先コンストラクターの呼び出し
{
  constructor-body...
}
```