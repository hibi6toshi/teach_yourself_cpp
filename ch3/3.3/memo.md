# 初期値を受け取るコンストラクタ
## コンストラクターは複数用意できる
コンストラクターの働きは1つはメンバー変数の初期化です。
その際、常に同じ初期値で初期化するのであれば前節で説明したコンストラクターだけがあれば問題ありませんが実際はさまざまな初期値を使うことのほうが多いでしょう。
コンストラクターは通常の関数と同様に引数を受け取ることができるため、引数を使って初期化を行うことができます。また、コンストラクターもオーバーロードできるので、ユーザーが使いやすいように複数のコンストラクターを用意することも可能です。

```
class class-name {
  public:
   class-name(parameters...); // 引数を受け取るコンストラクター
   ...
};

// インスタンスの生成とコンストラクター呼び出し
class-name variable-name(arguments...);
```

ただし、このとき注意しなければならないのは、引数を受け取るコンストラクターを1つでも定義してしまうと、コンパイラーが自動で生成するデフォルトコンストラクターがなくなってしまうということです。
**デフォルトコンストラクター**は引数がないコンストラクターのことで、通常はコンパイラーが自動的に何もしないデフォルトコンストラクターを定義します。しかしプログラマーがデフォルトコンストラクターを定義した場合にはそちらが使われます。
そのため、プログラマーがデフォルトコンストラクターを別途定義するか、インスタンスを作る際に必ず引数を渡す必要があります。

## 委譲コンストラクター
さらにコンストラクターで行う処理は「初期値が少し異なるだけで手順は同じ」というケースが多々ありあす。通常の関数であれば、関数の中から他のオーバーロードを呼ぶことが簡単にできるため、コンストラクターのそのようにできるかと思うかもしれませんが、コンストラクターは直接呼び出せない（オブジェクト生成時にしか呼び出せない）ので、他のコンストラクターを呼び出すための専用の方法が用意されています。これを**委譲コンストラクター**と呼びます。
委譲さきのコンストラクターが呼ばれてから、移譲元のコンストラクターの処理が続きます。委譲コンストラクターは処理の大部分を委譲先に任せます。
特にメンバー変数の初期化は委譲先でしかできず、移譲元のコンストラクターではメンバー変数の初期化はできません。

```C++
class class-name {
  public:
   class-name(parameters...); // 移譲元コンストラクターの宣言
   ...
};

class-name::class-name(parameters...) // 移譲元コンストラクターの定義
      : class-name(arguments...) // 委譲先コンストラクターの呼び出し
{
  constructor-body...
}
```

## コピーコンストラクター
コンストラクターには、プログラマーが書いた**ユーザー定義コンストラクター**の他に、デフォルトコンストラクターのようにコンパイラーが自動で生成する**コンパイラー生成コンストラクター**があります。
コンパイラー生成コンストラクターの中には、クラスをコピーする際に使われる**コピーコンストラクター**が存在します。
コピーコンストラクターの構文は以下の通りです。
```C++
class class-name {
  public:
   class-name(const class-name& variable-name); // コピーコンストラクター
};
```

## コピーコンストラクターはプログラマーが記述する
多くの場合はコンパイラーが生成するコピーコンストラクターをそのまま使えば問題ありませんが、メモリ領域やリソースを扱うクラスの場合はそれでは不都合が起きてしまう場合があります。
なぜならメンバー変数がポインター変数の場合、コンパイラーが生成するコピーではポインター変数の値（アドレス）のみコピーを行い、ポインター変数が指し示す先の実際のオブジェクトはコピーしないためです。ポインター変数の値のみコピーを行うと、オブジェクトは1つしか存在しないのに複数のクラスが同じアドレス値を持ってしまうことになり、それらオブジェクトが破棄されるたびにそれぞれ同じオブジェクトを解放しようとする**二重解放**を起こしてしまいます。
