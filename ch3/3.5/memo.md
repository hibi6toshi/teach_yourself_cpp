# 継承の概要

## 継承とは
1つのベースとなるクラスを作って、異なる部分だけ追加できる仕組み。
ベースとなるクラスを**基底クラス**とよび、基底クラスに機能を追加したりする方のクラスを**派生クラス**と呼びます。

他のクラスからメンバーを継承するには、派生クラスの定義時に基底となるクラスを指定します。
```C++
class derived-class-name : access-specifier base-class-name {
  ...
};
```

Deruved がBaseを継承するときにpublic指定をしています。
これは、規定クラスがpublicで公開しているメンバーを派生クラスでもpublicで後悔することを意味します。publicではなくprivateを指定することもできますが、その場合は規定クラスのメンバーを外部からアクセスすることはできません。ほとんどの場合はpublic指定をしておけば問題ないでしょう。

## 仮想関数とオーバーライド
派生クラスは、基底クラスのメンバーを継承した上で独自の機能を追加することができました。しかし機能を追加するのではなく、存在する機能の「処理内容」を変えたい場合もあります。
ただ、なんでも勝手に変更できてしまうと困るので、基底クラスを宣言する際に「このメンバー関数は派生クラスでも変更が可能である」と宣言できます。この宣言をされた関数のことを**仮想関数**といいます。
コンストラクター以外のメンバー関数は基本的に全て、仮想関数にすることができます。
他方、派生クラスでは仮想関数を**オーバーライド**することで動作を変更できます。これにはオーバーライドしたいメンバー関数に**override**指定子をつけます。規定クラスの処理をそのまま使用したい場合には、派生クラスでは特に何もオーバーライドしなければ、自動的に基底クラスの仮想関数を継承します。

オーバーライドするときには戻り値の型や関数名、引数の型や数さらにはconstメンバー関数かどうかまでが全て基底クラスのものと一致している筆お用があります。
```C++
class base-class-name {
  public:
    virtual return-type function-name(parameters...); // 仮想関数
};

return-type base-class-name::function-name(parameters...) { // 定義にはvirtualを書かない
  function-body...
}

class derived-class-name : public base-class-name {
  public:
    return-type funciton-name(parameters...) overfide; // 仮想関数のオーバーライド
};

return-type derived-class-name::function-name(parameters...){ // 定義にはoverrideを書かない
  function-body...
} 
```

実は基底クラスでvirtual指定さえしていれば派生クラスではoverride指定子を省略してもオーバーライドとなります。しかし、開発をしていると、気がつかないうちに規定クラスのメンバー関数が仮想関数でアンクなっていたり、受け取る型の引数が変わっていたりということがよくあります。また、オーバーロードは特に制限されることなく出来てしまうので、そのような場合「実はオーバーライドされすにオーバーロードになっていた」といったミスも起きてしまいます。

こういった際に、オーバーライドするつもりのメンバー関数にoverrideと指定することで、対応する仮想関数が基底クラスになかった場合にコンパイルエラーがエラーとして報告されます。
そのため、オーバーライドを意図している場合にはいつもつけるようにしてください。
一方、オーバーライドしたくない/オーバーライドではないということを指定する方法はないので、規定クラスが何を仮想関数としているかを注意深く調べねばなりません。

## 名前の隠蔽
基底クラスが持っているメンバー関数名と同じ名前のメンバー関数を派生クラスに追加すると、**名前の隠蔽**ということが起こります。派生クラスは規定クラスが持っているメンバーを継承するので、派生クラスを使っても規定クラスのメンバー関数を使えるはずですが、名前の隠蔽が起こると基底クラスのメンバー関数が呼び出せなくなってしまいます。

名前の隠蔽は、特に派生クラスでオーバーロードを追加しようとしたときに起こることが多いです。

こういった場合にはusing宣言を使うと規定クラスのメンバー関数をオーバーロードとして追加できます。using宣言は型に別名を与えるところでも使いましたが、これはそれとは違う用途のusing宣言となります。
```
class class-name : access-specifier base-class {
  public:
    using base-class-name::member-function-name;
};
```
using宣言はアクセス指定子の影響を受けます。つまりprivateとなっている範囲でusing宣言をしても、あくまでクラス内で使えるだけでクラスの外部からは呼び出すことができなくなります。

## 純粋仮想関数と抽象クラス
仮想関数には、基底クラスでは宣言のみで関数定義（処理内容）がなく、派生クラスが必ずオーバーライドをして処理を書くように強制させる**純粋仮想関数**というものがあります。
処理の流れは決まっているけど、具体的な関数処理内容は実際に派生クラスにならないと決められないといった場合によく使われます。

```
class class-name {
  public:
    virtual return-type function-name(parameters...) = 0; // 純粋仮想関数
};
```

### 抽象クラス
純粋仮想関数が宣言されたクラスは**抽象クラス**と呼ばれます。抽象クラスに多くのクラスで共通となる処理の流れを書いておいて、派生クラスで使いまわせるようにすることがあります。
また、純粋仮想関数は処理の内容学科いていない不完全なものなので、抽象クラスだけではインスタンス化すること
ができなくなります。

```C++
class abstract_class {
public:
  virtual void foo() = 0;
};

abstract_class ac; // エラー。抽象クラスのインスタンスは作れない。
```

他の言語にある**インターフェース**という機能を模倣するために抽象クラスが使われることがあるが、インターフェースのためだけに抽象クラスを使うのはパフォーマンスの点からあまり好ましいと言えません。
設計から変更できるならインターフェースのような使い方は避けるようにした方が良い。
