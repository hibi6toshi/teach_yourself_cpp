# 継承の概要

## 継承とは
1つのベースとなるクラスを作って、異なる部分だけ追加できる仕組み。
ベースとなるクラスを**基底クラス**とよび、基底クラスに機能を追加したりする方のクラスを**派生クラス**と呼びます。

他のクラスからメンバーを継承するには、派生クラスの定義時に基底となるクラスを指定します。
```C++
class derived-class-name : access-specifier base-class-name {
  ...
};
```

Deruved がBaseを継承するときにpublic指定をしています。
これは、規定クラスがpublicで公開しているメンバーを派生クラスでもpublicで後悔することを意味します。publicではなくprivateを指定することもできますが、その場合は規定クラスのメンバーを外部からアクセスすることはできません。ほとんどの場合はpublic指定をしておけば問題ないでしょう。

## 仮想関数とオーバーライド
派生クラスは、基底クラスのメンバーを継承した上で独自の機能を追加することができました。しかし機能を追加するのではなく、存在する機能の「処理内容」を変えたい場合もあります。
ただ、なんでも勝手に変更できてしまうと困るので、基底クラスを宣言する際に「このメンバー関数は派生クラスでも変更が可能である」と宣言できます。この宣言をされた関数のことを**仮想関数**といいます。
コンストラクター以外のメンバー関数は基本的に全て、仮想関数にすることができます。
他方、派生クラスでは仮想関数を**オーバーライド**することで動作を変更できます。これにはオーバーライドしたいメンバー関数に**override**指定子をつけます。規定クラスの処理をそのまま使用したい場合には、派生クラスでは特に何もオーバーライドしなければ、自動的に基底クラスの仮想関数を継承します。

オーバーライドするときには戻り値の型や関数名、引数の型や数さらにはconstメンバー関数かどうかまでが全て基底クラスのものと一致している筆お用があります。
```C++
class base-class-name {
  public:
    virtual return-type function-name(parameters...); // 仮想関数
};

return-type base-class-name::function-name(parameters...) { // 定義にはvirtualを書かない
  function-body...
}

class derived-class-name : public base-class-name {
  public:
    return-type funciton-name(parameters...) overfide; // 仮想関数のオーバーライド
};

return-type derived-class-name::function-name(parameters...){ // 定義にはoverrideを書かない
  function-body...
} 
```

実は基底クラスでvirtual指定さえしていれば派生クラスではoverride指定子を省略してもオーバーライドとなります。しかし、開発をしていると、気がつかないうちに規定クラスのメンバー関数が仮想関数でアンクなっていたり、受け取る型の引数が変わっていたりということがよくあります。また、オーバーロードは特に制限されることなく出来てしまうので、そのような場合「実はオーバーライドされすにオーバーロードになっていた」といったミスも起きてしまいます。

こういった際に、オーバーライドするつもりのメンバー関数にoverrideと指定することで、対応する仮想関数が基底クラスになかった場合にコンパイルエラーがエラーとして報告されます。
そのため、オーバーライドを意図している場合にはいつもつけるようにしてください。
一方、オーバーライドしたくない/オーバーライドではないということを指定する方法はないので、規定クラスが何を仮想関数としているかを注意深く調べねばなりません。
