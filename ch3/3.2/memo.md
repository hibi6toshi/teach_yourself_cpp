
# コンストラクターとデストラクター
　C++では初期化を行うための**特殊なメンバー関数**である、**コンストラクター**を定義できます。コンストラクターは初期化の処理を自動化できる利点があります。

## コンストラクターの構文
コンストラクターは、クラス名と同じでメンバー関数を記述することで定義できます。その代わり、通常のメンバー関数にクラス名と同じ名前を使うことはできません。
```C++
class class-name {
  public:
    class-name(); // コンストラクタの宣言
    ... 
};

// コンストラクタの定義
class-name::class-name() : member(initial-value), member(initial-value)... {
  constructor-body...
}
```

## コンストラクターと他の関数との違い
- 戻り値がない

コンストラクターには戻り値の型というものが書かれていません。コンストラクターの実行結果は常に構築したインスタンス自身であり、戻り値の方が自明なため戻り値の方を書
くことはできません。（記述した場合はエラーになります。）

- メンバー初期化リスト

コンストラクター本体の前に見慣れない、コロン(:) で始まる部分があります。この部分のことを**メンバー初期化リスト**と呼びます。メンバー初期化リストを使っての初期化は、コンストラクター本体の処理よりも必ず先に行われます。また、メンバー初期化リストで省略されたメンバーは、メンバー初期化リストと同じタイミングでデフォルト値に初期化されます。
メンバー変数の初期化をコンストラクターの本体で行うこともできますが、メンバー初期化リストを使うことで、他のクラスのオブジェクトをメンバー変数にした場合でも、そのオブジェクトの適切なコンストラクターを呼び出すことができます。

特に適当な初期値がない場合、不正値で初期化することで、まだ有効な値が格納されていないことを表すこともできます。

## デストラクター
クラスのコンストラクターでは、そのクラスが正常に動作するのにメンバー変数以外にも必要であれば、追加でメモリー領域を確保します。
また、確保したメモリ領域は必ず解放します。プログラムの中で適切にメモリ領域を解放しないと、メモリ領域を確保したままとなってしまい、やがてメモリ不足に陥ります。これを**メモリーリーク**と呼びます。メモリーリークはよく起こるのですが、どこで起きているかを見つけ出すのが難しい、厄介なバグの一つです。
メモリーリークを防ぐためにも確保したメモリ領域は、使わなくなったところで解放するべきです。しかし、不要になったとしてもクラスのプライベートメンバー変数はクラスの外からアクセスできないため、そのメモリ領域を解放できません。

この問題を解決するために使われるのが**デストラクター**です。コンストラクターは初期化時に呼び出される特殊メンバー関数でしたが、デストラクターはインスタンスが破棄される時に呼ばれる特殊メンバー関数です。インスタンスが破棄されるタイミングというのは決まっていますが、大雑把には関数本体などの閉じブレースのタイミングになります。
デストラクターの構文は次の通りです。
```
class class-name {
  public:
    ~class-name(); // デストラクターの宣言
    ...
};

class-name::~class-name() { // デストラクターの定義
  destructor-body...
}
```
デストラクターは値を返すことができないため戻り値の型は書けませんし、引数を受け取ることもできないため、引数も書くことができません。

## RAII
コンストラクターで必要なメモリ領域を確保して、デストラクターで解放することを**RAII**(Resource Acquisition Is Initialization) と言います。RAIIはC++特有のテクニックという訳ではないですが、確保したメモリ領域そ自動的に解放する仕組みである**GC(ガベージコレクション)**を持たないC++では、非常に重要な機能となります。

ほとんどの場合、デストラクターは不要なはずですが、動的に確保したメモリ領域の解放やNoteが提供する特殊なリソースの返却は、プログラムを書く人が責任も持って行わねばなりません。