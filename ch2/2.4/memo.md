# 型推論

## 変数の型と初期値の型
変数の宣言時に初期値を与えているとき、変数のかたと初期値のかたを別にしたいというケースおは稀であり、むしろどちらも同じ型になっていた方が自然でしょう。
初期値の方にすでに決まった型があるので、その方を使って変数を宣言するようにコンパイラーに指示する機能があります。
この機能のことを**型推論**(type deduction)といい、次のような構文で変数を宣言します。
```
auto variable-name = initial-value;
```

注意しなければならないのは、上記形式の型推論が使えるのは初期値がある場合のみ。

## 範囲for文の型推論
範囲for文では（例外的に）型推論する際の初期値が不必要である。
範囲for文で捜査するときに得られる各要素の型にautoを書くと、要素の型を推論したうえでループします。

## 式の型を推論する
任意の式の型を調べる構文があります。これは初期値を持たない変数の宣言や、後ほど説明するテンプレートなどで使われます。

式から型を得るには次の構文を使います。
```
decltype(expression)
```

このdecltypeを型の代わりに使って、変数宣言なども行えます。

## 配列の型推論
配列の型を推論しようとする場合は注意が必要です。例えば、配列の型推論を意図して次のように書いたとしても、意図通りにはなりません。
```
auto array[] = { 0, 1, 2, 3, 4 }; // エラー。autoの配列は作れない。
auto array[] { 0, 1, 2, 3, 4 }; // エラー。autoの配列は作れない。

auto array = { 0, 1, 2, 3, 4 }; // 注意。これは配列でない別のものになる。
  // -> std::initializer_list<int> というものになる。
auto array{ 0, 1, 2, 3, 4 }; // 特に注意。　配列でない上に、推論されるかたが条件によって変わる。
　// -> {} の中の要素の数が1つの場合はその型に、そうでない場合はstd::initializer_listになる。
```

## 型の別名定義
型に別名(type alias)を与えることがあります。例えば、関数やクラスで使う型に別名を与えておき、必要な箇所でその名前を確認しなくても、別名の定義箇所を変更するだけでプログラム全体が新しい型を使うようになります。
これは特にクラスのメンバー変数・メンバー関数・テンプレートなどで威力を発揮します。
型に別名を与えるには**using**宣言を使います。
```
ysubg bew0type-name = old-type-name;
```

