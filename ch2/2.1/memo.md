# 構造体・共用体・列挙体

## 構造体 structure
構造体は複数の変数を1つの変数としてまとめて扱うための型を作る機能です。
構造体の定義の方法（最後のセミコロンを忘れない）
```
struct struct-name {
  menber-type1 member-name1;
  menber-type2 member-name2;
  ...
};
```

構造体でまとめられた変数のことをメンバー変数（member variable）という。
メンバー変数として他の構造体の変数を宣言できる。
構造体のポインターをメンバにすることもできる。

構造体のメンバーにアクセスするに**ドット演算子（. :dot operator）**と**アロー演算子(-> :arrow operator)**を使います。
ドット演算子とアロー演算子の違いは、アクセスする先の構造体が構造体変数なのか（ドット演算子）、構造体のポインターなのか（アロー演算子）という点です。

構造体変数は複数のメンバ変数を持つため、{} を使って配列のときのように初期値を一括して渡します。
{} の中には、構造体の定義で書いた順番通りにメンバー変数の数（もしくは少ない。その場合、不足分は0で初期化）だけ初期値を記述します。
```
struct product {
  int id; // 商品ID
  int price; // 単価
  int stock; // 在庫数
};

int main() {
  // 構造体の初期化
  // 構造体の定義で書いた順番通りに初期値を書く
  product pen = {
    0, // 商品ID
    100, // 単価
    200, // 在庫数
  };
}
```

## 共用体(union)
共用体は、構造体同様メンバー変数をもっているものですが、それらメンバー変数が全て同一のアドレス上に存在していることが違っています。複数のメンバー変数が同一アドレス上に存在するため、どれか一つを書き換えた場合、他のメンバー変数も全て描き変わります。
```
union union-type {
  member-type1 member-name1;
  member-type2 member-name2;
  ...
};
```
初期化は先頭のメンバー変数のみが初期化できる。

## 列挙体(enumeration)
列挙体は、構造体や共用体とは少し異なり、メンバー変数を持たない。「列挙体が取りうる値を列挙しておき、そのうちのいずれかの値を持っている。」変数を作るための型です。

```
enum class enum-name {
  enumerator1,
  enumerator2 = value,
  ...
};
```
列挙体は取りうる値をカンマ区切りで列挙するだけで宣言できますが、その場合、それぞれの値には具体的な整数値が0から順番に割り当てられます。

列挙体名と列挙値をスコープ解決演算子(:: scope resolution operator) で繋げるとその値を使うことができます。
```
enum-name::enumerator;
```

列挙体で扱える整数の範囲を指定する方法がある。
```
enum class enum-name : underlying-type {
  enumeration1,
  enumeration2 = value,
  ...
}
```

underlying-type にはenumで扱うベースとなる整数型を指定します。 組み込みの整数型のみ指定ができます。
特にchar は1バイトであることが決まっているので、1バイトのenumを作りたいときはchar型をベースにしたenumを作ると良い。


