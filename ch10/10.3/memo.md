# 10.3 new演算子の例外処理
## 10.3.1 std:bad_alloc例外
new演算子は動的メモリを確保するために使われる演算子ですが、必要なメモリを確保できなかった場合std::bad_alloc例外が投げられます。
この例外は標準ライブラリで規定されているstd::exception例外から発生した例外の1つで、<new>ヘッダーにおいて定義されています。

new演算子が割り当てに失敗した場合、それは動的メモリを確保できないということを意味します。そのため、例外ハンドラーの中でも動的メモリを使用するような処理はほとんど不可能だと考えられます。一般的にこの種の例外は、受け取ったからといって何か手立てがあるわけではないので、そもそもcatchすらしない(std::terminate()関数で終了させるしかない) 場合がほとんどです。

catch節では例外オブジェクトを参照を使って捕まえています。一般に例外オブジェクトは、例外が投げられた段階での様々な情報を持っていて、コピーをしてしまうとメモリの動的確保をしてしまうかもしれません。例外オブジェクトのコピーはcatch節に処理が完全に映る前になされるので、このタイミングでさらに例外が投げられると**ダブルフォルト**といって強制終了されます。
ダブルフォルトを防ぐためにも、例外オブジェクトがクラスの場合には参照で捕まえるようにしてください。

## 10.3.2 std::bad_array_new_length例外
new演算子は、1つのオブジェクトを確保するためだけでなく、配列を確保するためにも使われました。
```C++
int* array = new int[5]{0, 1, 2, 3, 4};
```

配列の全要素のメモリを確保できなかった場合にもstd::bad_alloc例外が投げられるのは同じですが、このように初期化リストを渡して初期化する場合にはstd::bad_array_new_length例外という別の例外が投げられることがあります。これは、初期化リストの長さよりも実際に確保した動的配列が短かった場合の例外です。
なお初期化リストの方が短かった場合には例外は創出されず、指定した長さだけ配列を確保して初期化リストで初期化し、残りの要素は0で初期化されます。
