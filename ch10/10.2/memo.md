# 10.2 例外処理の詳細

## 10.2.1 すべてを捕まえるcatch節
catch説では特定の型の例外オブジェクトが投げれらた場合にその例外を処理できました。しかし、どのような例外が投げられるかわからない場合、そのままだとプログラムは強制終了させられてしまいます。そこで、「具体的な例外オブジェクトはわからないが、とにかく例外を全て捕まえる」という特別なcatch節があります。
```C++
// 全ての例外を捕まえるcatch節
catch (...) {
  // 全ての例外を捕まえることができる
  statement...
}
```
このcatch節は、tryブロックに続くcatch節の**最後に1つだけ**記述することができます。このとき、どの例外オブジェクトであっても捕まえることができる代わりに、その例外オブジェクトの値を取得することはできません。

## 10.2.2 例外の再送出
例外が投げられると、catch節に一気に処理が移動します。場合によっては、途中で確保していたリソースなどを解放しないとメモリリークが起きてしまうかもしれません。
```C++
void throw_zero() {
  char* buffer = new char[10];　// 何かの処理をするためのバッファー
  ...
  throw 0;
  delete [] buffer; // throwで処理が別のところに飛ぶのでこのdeleteは呼ばれない。
}
```

上記のよう場場合、例外に対する適切な処理をその場でできなくても、一度捕まえてリソースを解放してからもう一度例外を投げることでメモリリークなどを防ぐことができます。
```C++
void throw_zero() {
  char* buffer = new char[10]; // 何かの処理をするためのバッファー

  try {
    ...
    throw 0;
  } catch (int e) {
    // 一度例外を捕まえて、バッファーを解放してから同じ例外をして投げる
    delete [] buffer;
    throw e;
  }

  delete [] buffer;
}
```
しかし、この方法には2点問題があります。

1. catch(...) では、もう一度投げるべき例外オブジェクトがわからない
2. 2つ目に投げられる例外オブジェクトは、1つ目の「コピー」が投げられる

1つ目は特に問題で、「知っている例外でしかメモリリークを防ぐことができない」ような場合、ありとあらゆる例外を捕まえられるよう、無数のcatch節を書かなければなりません。しかも、知らない例外が投げられた場合には、もはやなす術がありません。

この場合、何も例外オブジェクトを指定しないthrow文で、catch節が捕まえた例外をもう1回投げることができます。このように捕まえた例外をもう一度投げることを特に**例外の再送出**といいます。あの、何も例外オブジェクトを指定しないため、catch(...)のように具体的な例外オブジェクトの型がわからなくても再送出は可能です。


