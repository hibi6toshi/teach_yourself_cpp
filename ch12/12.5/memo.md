# 12.5 std::setとstd::map

## 12.5.1 std::set
標準ライブラリには要素が大小に基づいて昇順に並んでいるコンテナがいくつか存在します。そのうち、要素の重複がないものがstd::set<T>であり、<set>ヘッダーに定義されています。
std::setはイテレーターを使って走査すると昇順に並んでいますが、std::vectorやstd::listのように順番に走査するのに適した内部構造になっていません。そのため、ただ要素が整列しているコンテナがほしいのであればstd::vectorなどのコンテナを使い、適宜ソートする方が良いでしょう。

**初期化**
初期化時に引数を何も渡さなければ空のstd::setが作られるのは他のコンテナと同様です。またstd::vectorやstd::listと同じく、std::initializer_listを使った初期化が可能あり、事前に要素がわかっている場合には{}を使って初期化できます。
```C++
std::set<int> empty; // 空のstd::set

std::set<int> s = { 0, 1, 2, 3, 4 }; // {}を使った初期化
```

**要素の検索**
要素を昇順に並べるのは高速な検索をするためです。std::vector/std::listだと、要素の検索はコンテナ内を先頭から末尾まで順に比較することになるため、**時間計算量**はO(N)ですが、std::setは要素が昇順に並んでいるため二分探索というアルゴリズムによりO(logN)に抑えられます。
そのため、std::setには高速に要素を検索できるfind()メンバー関数が用意されています。
```C++
iterator find(const T& value);

const_iterator find(const T& value) const;
```

find()メンバー関数は検索対象の要素が見つかると、その要素へのイテレーターを返します。見つけることができなかった場合にはend()メンバー関数が変えるイテレーターを返します。
そのため、find()メンバー関数から受け取った結果は常に有効というわけではなく、常にend()メンバー関数と比較しなければなりません。

**要素の挿入**
std::vector/std::listでは、要素の挿入時にイテレーターを使って挿入位置を指定していました。
```C++
std::list il = { 0, 1, 3, 4 };
auto iter = il.begin();

std::advance(iter, 2); // iter は3を指す

il.insert(iter, 2); // 3の直前に2を挿入
il.push_back(5); // 末尾に5を挿入
```

対してstd::setでは、各要素が要素の大小に基づいて昇順に並んでいるため、挿入位置の指定が基本的には意味を持ちません。そのため、挿入位置を与えないinsert()メンバー関数が良いされています。

std::setは要素の重複を許しません。

**要素の変更・削除**
std::set内の要素は常に昇順にソートされた状態が保たれていなければならないので、イテレーターを介してset内の要素を変更することはできません。
要素の変更は、erase()メンバー関数により削除を行なった後で、insert()メンバー関数を使って新しい要素を挿入することで実現します。

```C++
#include <set>

int main() {
  std::set is = { 1, 3, 5, 7 };
  auto iter = is.find(3);

  *iter = 4; // コンパイルエラー。　コンテナ内の要素は変更できない

  is.erase(iter); // 3を削除
  is.insert(4); // 4を代入
}
```

std::listと同じく、、std::setに対して挿入・削除を行なってもイテレーターは（削除された要素を指していないのであれば）無効にはなりません。

## 12.5.2  std::map
std::map<K,V>テンプレートクラスはstd::setの変種といえるコンテナであり、ヘッダー<map>に定義されています。
std::map<K,V>はKを**キー**、Vを（キーに紐づけられた）**値**とする**辞書**として機能します。
そのためにstd::mapはキーの大小を元に並べ替え、キーの重複がないようにしています。値については重複しても問題ありません。

また添字演算子により、キーを添え字にしてそのキーと対になる値の参照を取得できます。そのため、Kを添え字とする**連想配列**と見なすこともできます。指定されたキーがコンテナ内に存在しなかったときは、デフォルトコンストラクターで生成されたVの値を用いてコンテナ内に自動的に挿入されてからその参照が返されます。

std::map<K,V>は他のコンテナクラスとは値の格納方法が異なり、イテレーターを間接参照するとstd::pair<const K, V>への参照が返ってきます。範囲for文で走査するときにもstd::pair<const K, V>で渡されてくるので注意してください。
{} を使った初期化の時にもキーと値をセットにして渡す必要があります。
```C++
std::map<std::string, int> m = {
  std::pair{"first", 1},
  std::pair{"second", 2},
};

m["first"] == 1; // true
```

## 12.5.3 std::multisetとstd::multimap
要素が昇順に並んでいるものの、std::setとは少し異なり「要素の重複」を許すコンテナstd::multisetも、ヘッダー<set>に定義されています。std::multisetの使い方は基本的にstd::setと同じです。

find()メンバー関数も使えますが、これが返すイテレーターは最初に見つけた要素へのイテレーターとなります。しかし、実際には同じ要素を全て取得したいという場合が多くあります。find()メンバー関数だけでは最初の要素しかわからないので少々使いづらいです。
equal_range()メンバー関数を使うと、重複している要素の範囲を返すので簡単に列挙できます。
```C++
std::pair<iterator, iterator> equal_range(const Key& key);

std::pair<const_iterator, const_iterator> equal_range(const Key& key) const;
```

std::multimapもstd::multiset同様にstd::mapが要素の重複を許すようになったコンテナです。こちらもほとんど同様に扱うことができますが、std::multimapはstd::mapでできた添字演算子での要素アクセスができなくなっています。(重複しているのでその要素を返せば良いかがわからないため)。
重複した要素どうしの並び順は、挿入した順番になるようになっています。これはstd::multisetでもそのようになっているのですが、std::multimapを使用する時には特に重要な性質となります。
std::multimapでもequal_range()メンバー関数が提供されており、std::multisetのそれと全く同じように使えます。
