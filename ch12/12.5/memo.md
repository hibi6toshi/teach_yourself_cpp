# 12.5 std::setとstd::map

## 12.5.1 std::set
標準ライブラリには要素が大小に基づいて昇順に並んでいるコンテナがいくつか存在します。そのうち、要素の重複がないものがstd::set<T>であり、<set>ヘッダーに定義されています。
std::setはイテレーターを使って走査すると昇順に並んでいますが、std::vectorやstd::listのように順番に走査するのに適した内部構造になっていません。そのため、ただ要素が整列しているコンテナがほしいのであればstd::vectorなどのコンテナを使い、適宜ソートする方が良いでしょう。

**初期化**
初期化時に引数を何も渡さなければ空のstd::setが作られるのは他のコンテナと同様です。またstd::vectorやstd::listと同じく、std::initializer_listを使った初期化が可能あり、事前に要素がわかっている場合には{}を使って初期化できます。
```C++
std::set<int> empty; // 空のstd::set

std::set<int> s = { 0, 1, 2, 3, 4 }; // {}を使った初期化
```

**要素の検索**
要素を昇順に並べるのは高速な検索をするためです。std::vector/std::listだと、要素の検索はコンテナ内を先頭から末尾まで順に比較することになるため、**時間計算量**はO(N)ですが、std::setは要素が昇順に並んでいるため二分探索というアルゴリズムによりO(logN)に抑えられます。
そのため、std::setには高速に要素を検索できるfind()メンバー関数が用意されています。
```C++
iterator find(const T& value);

const_iterator find(const T& value) const;
```

find()メンバー関数は検索対象の要素が見つかると、その要素へのイテレーターを返します。見つけることができなかった場合にはend()メンバー関数が変えるイテレーターを返します。
そのため、find()メンバー関数から受け取った結果は常に有効というわけではなく、常にend()メンバー関数と比較しなければなりません。

**要素の挿入**
std::vector/std::listでは、要素の挿入時にイテレーターを使って挿入位置を指定していました。
```C++
std::list il = { 0, 1, 3, 4 };
auto iter = il.begin();

std::advance(iter, 2); // iter は3を指す

il.insert(iter, 2); // 3の直前に2を挿入
il.push_back(5); // 末尾に5を挿入
```

対してstd::setでは、各要素が要素の大小に基づいて昇順に並んでいるため、挿入位置の指定が基本的には意味を持ちません。そのため、挿入位置を与えないinsert()メンバー関数が良いされています。

std::setは要素の重複を許しません。

**要素の変更・削除**
std::set内の要素は常に昇順にソートされた状態が保たれていなければならないので、イテレーターを介してset内の要素を変更することはできません。
要素の変更は、erase()メンバー関数により削除を行なった後で、insert()メンバー関数を使って新しい要素を挿入することで実現します。

```C++
#include <set>

int main() {
  std::set is = { 1, 3, 5, 7 };
  auto iter = is.find(3);

  *iter = 4; // コンパイルエラー。　コンテナ内の要素は変更できない

  is.erase(iter); // 3を削除
  is.insert(4); // 4を代入
}
```

std::listと同じく、、std::setに対して挿入・削除を行なってもイテレーターは（削除された要素を指していないのであれば）無効にはなりません。
