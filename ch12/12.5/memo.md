# 12.5 std::setとstd::map

## 12.5.1 std::set
標準ライブラリには要素が大小に基づいて昇順に並んでいるコンテナがいくつか存在します。そのうち、要素の重複がないものがstd::set<T>であり、<set>ヘッダーに定義されています。
std::setはイテレーターを使って走査すると昇順に並んでいますが、std::vectorやstd::listのように順番に走査するのに適した内部構造になっていません。そのため、ただ要素が整列しているコンテナがほしいのであればstd::vectorなどのコンテナを使い、適宜ソートする方が良いでしょう。

**初期化**
初期化時に引数を何も渡さなければ空のstd::setが作られるのは他のコンテナと同様です。またstd::vectorやstd::listと同じく、std::initializer_listを使った初期化が可能あり、事前に要素がわかっている場合には{}を使って初期化できます。
```C++
std::set<int> empty; // 空のstd::set

std::set<int> s = { 0, 1, 2, 3, 4 }; // {}を使った初期化
```

**要素の検索**
要素を昇順に並べるのは高速な検索をするためです。std::vector/std::listだと、要素の検索はコンテナ内を先頭から末尾まで順に比較することになるため、**時間計算量**はO(N)ですが、std::setは要素が昇順に並んでいるため二分探索というアルゴリズムによりO(logN)に抑えられます。
そのため、std::setには高速に要素を検索できるfind()メンバー関数が用意されています。
```C++
iterator find(const T& value);

const_iterator find(const T& value) const;
```

find()メンバー関数は検索対象の要素が見つかると、その要素へのイテレーターを返します。見つけることができなかった場合にはend()メンバー関数が変えるイテレーターを返します。
そのため、find()メンバー関数から受け取った結果は常に有効というわけではなく、常にend()メンバー関数と比較しなければなりません。
