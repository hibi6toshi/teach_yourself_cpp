# 12.1 コンテナクラス
**コンテナ**とは容器・入れ物のことであり、**コンテナクラス**とはデータの集合を表現するクラスの総称です。std::stringも（一列に並んだ）文字の集合であり、文字を要素としたコンテナです。配列も、言語使用で用意されたデータの集合、すなわちコンテナだと言えます。
```C++
int sarray[10]; // 要素数10のint集合
```

配列の要素数はコンパイル時に決定され、実行時に変更することはできません。実行時に要素数を決定する動的配列はポインターとnew演算子/delete演算子によって作ることができます。
```C++
int* darray = new int[size]; // 要素数sizeのint集合
// ...
delete[] darray;
```

ただ、この動的配列は「動的」といいながら、要素数に合わせてデータの格納領域が自動的に増減するものではありません。領域の管理はプログラマーの手に委ねられています。
とはいえ、要素数の挿入・削除のたびにコードを書くのは煩わしく、またメモリリークや領域外参照のバグの原因となります。

また、要素の挿入・削除もかなり面倒です。配列は各要素が連続しているため、配列の任意の位置に要素を挿入するには、それ以降に並ぶ全要素を1つずつ後方に移動して空きを作らねばなりません。同様に削除するには、それ以降の要素を1つずつ手前に移動して空きを埋めなくてはなりません。そのため、先頭に近い要素ほど、挿入・削除に時間がかかります。

コンテナのデータ構造によって、挿入・削除、列挙・参照、検索などの処理に要する時間（効率）が異なります。
標準ライブラリは、プログラマーが目的に応じて選べるようにデータ構造の異なる各種コンテナを提供します。

## 12.1.1 イテレーター
イテレーターは反復子と呼ばれ、コンテナ内の各要素を参照するときの「ポインターのようなもの」です。

memo:
firstとlastの組で範囲を表すとき、「firstを始点とし、lastに達しない範囲」を、以降、[first, last)と表記します。

関数テンプレートを使うことで、int型の配列以外のコンテナを扱えるようにする。
```C++
template <typename Iterator, typename T>
T sum_all(Iterator first, Iterator last, T val) {
  while (first != last) {
    val += *first;
    ++first;
  }

  return val;
}
```

このsum_all()関数は、テンプレート引数であるIteratorが
1. !=(比較演算子)で比較できること
2. 関節参照演算子で要素を参照できること(*first)
3. インクリメント演算子で次の要素を指すこと(++first)

という3つの要件を満たす場合、正しく動いてくれます。

コンテナ内の要素がどんなデータ構造を持っていても、上記3つの要件を満たすイテレーターを2つ手に入れることができるならば、sum_all()関数を使って総和を計算することができます。
つまり、データ構造とアルゴリズムを分離・独立させるのがイテレーターというわけです。

## 12.1.2 イテレーターの種類
1. !=(比較演算子)で比較できること
2. 関節参照演算子で要素を参照できること(*first)
3. インクリメント演算子で次の要素を指すこと(++first)
の3つの要件を満たすイテレーターは**入力イテレーター**と呼ばれます。
1.と3.に加え、
4. 関節参照演算子によって要素を書き換えられること
を満たすならば**出力イテレーターと**と、1~4を全て満たす（イテレーターの指す全ての要素に読み書きできる）ならば、**順方向イテレーター**と呼ばれます。
5.デクリメント演算子で1つ前の要素を指すことが可能ならば、**双方向イテレーター**と、
6.加算/減算演算子で整数値を足す/引くことで任意の数だけ進んだり戻ったりできることができるならば、**ランダムアクセスイテレーター**に分類されます。
