# 12.2 std::vector
std::vectorはstd::stringと並んで最も使用頻度の高い代表的なコンテナです。
std::vectorは各要素が隙間なく連続していることが保証されています。
そのためstd::vectorの要素へのアクセスは配列と同じ速度でできるようになっています。

std::vectorには、コンテナに対する基本的な操作
- インスタンスの生成・破棄
- イテレーターによる要素のアクセス
- 代入・削除
を持っています。

## 12.2.1 インスタンスの生成と破棄
**空のコンテナの生成**
int型を要素とし、要素数0すなわち内部に要素を持たない空のstd::vectorを生成するには以下のように記述します。
```C++
std::vector<int> iv;
``

**要素数nのコンテナの生成**
5つのstd::string("apple")を要素とするstd::vectorを生成するには、以下のように記述します。
```C++
std::vector<std::string> sv{5, "apple"};
```

要素がデフォルトコンストラクターもしくは規定値を持っている場合は第2引数を省略でき、以下のように記述することができます。この場合、svには5つの空文字列が格納されています。
```C++
std;:vector<std::string> sv{5};
```

**コンテナのイテレーター**
std::vectorに限らず、コンテナは基本的に先頭と末尾の次を指すイテレーターを、それぞれbegin()メンバー関数とend()メンバー関数で取得できるようになっています。そしてbegin()メンバー関数とendメンバー関数でイテレーターを取得できるコンテナは範囲for文で走査させることができるようになっています。
なお、std::vetorはランダムアクセスができるコンテナであり、そのイテレーターはランダムアクセスイテレーターです。

**イテレーターに呼ぶインスタンス生成**
コンストラクターにイテレーターを2つ与えることで、そのイテレーターが指す範囲の要素群（例）によりインスタンスが生成されます。
そこで、"apple"というstd::string型の変数sの先頭(s.begin())と末尾の次(s.end())を引数に取るコンストラクターでstdd::vector<char>を生成する例

```C++
  std::string s = "apple";

  // sの先頭から末尾をもとに、std::vectorを生成する
  std::vector<char> cv{s.begin(), s.end()};
```
この例では、s.begin()が'a'を、s.end()が'e'の直後を指すので、cvには'a', 'p', 'p', 'l', 'e' が格納されます。
ポインターもまたイテレーターとして機能するため、以下のようにインスタンスを生成することも可能です。
```C++
const char fruit[] = "apple";
std::vector<char> cv{fruit, fruit + 5}; // fruitの先頭と6文字目（末尾）
```

**std::initializer_listによるインスタンス生成**
std::initializer_list<int>の各要素1~5がivに格納されます。
見かけと、配列の初期化と同じ記述になっています。

```C++
  // std::intializer_listによる生成
  std::vector<int> iv = {1, 2, 3, 4, 5};
```

**初期化文からの型推論**
std::vectorはクラステンプレートの型推論をサポートしています。

```C++
std::vector iv = { 0, 1, 2, 3, 4}; // std::vector<int>に推論される
```

**コピー**
std::vectorのコピーを作るには、以下のように記述します。
iv1にiv0の各要素がコピーされます。

```C++
  std::vector iv0 = { 1, 2, 3, 4, 5}; // コピー元
  std::vector iv1 = iv0; // コピー
```

**リサイズ**
配列と比べた際の動的配列の利点は、後から長さを変えられることにあります。resize()メンバー関数を使うことで、好きなタイミングで好きな長さに変更できます。

```C++
void resize(size_type n);

void resize(size_type n, const T& value);
```

このとき、短くする場合にはオーバーしている後ろの要素が破棄され、長くする場合には新規に増える部分はデフォルト値もしくは第2引数に渡した値を使って初期化されます。

**インスタンスの破棄**
std::vector<T>が破棄されるとき、格納されていた要素も全て破棄されます。
ただし、std::vector<T>の要素Tがポインターである場合は、ポインターの破棄の際にdelete(delete [])が自動的に行われないため注意しましょう。

以下のコードではメモリリークになります。
```C++
{
  char* pa = new char[5];
  char* pb = new char[10];

  std::vector pv = { pa, pb };

  ...

  // ここでstd::vector内のポインターは破棄されるが、
  // delete[]されないのでメモリリークとなる
}
```