# 12.3 std::list
std::vectorは連続するメモリ領域に隙間なく並んだ要素列でした。
それに対してstd::list(<list>ヘッダーで定義)は、各要素が「次の要素と前の要素を指す2つのポインター」を持っており、双方向のリンクで数珠繋ぎになっているコンテナです。
したっがて、std::listに対する要素の挿入・削除はリンクの張り替え（ポインターの付け替え）を行うのみで要素の移動を伴わないため、挿入・削除の位置によらず処理時間は一定（かつ高速）です。

## 12.3.1 std::listの基本動作
std::vectorで紹介した操作のうち、添字演算子を除く全ての操作が、std::listでもそのまま適用できます。ただし、std::listイテレーターは双方向イテレーターであることに注意してください。つまり、インクリメント/デクリメント演算子により1つずつ前後の要素へ移動できるものの、begin() + n のようにn個進んだり戻ったりすることはできません。

**双方向イテレーターの操作**
双方向イテレーターの操作について

ランダムアクセスイテレーターは、+演算子や-演算子に整数値を渡すことで指す要素を進めたり戻したりすることができました。
しかし双方向イテレーターにはそれらの演算子は用意されていないため、標準ライブラリの<iterator>ヘッダーに以下のように定義されているテンプレート関数を利用します。

```C++
// 双方向イテレーターを移動するためのテンプレート関数
template <typename Iterator, typename Distance>
void std::advance(Iterator* it, Distance n);

template <typename Iterator>
Iterator std::next(Iterator it, integer-type n =  1);

template <typename Iterator>
Iterator std::prev(Iterator it, integer-type n = 1);
```

このうち、std::advance()関数は第1引数に参照として受け取ったイテレーターを第2引数nだけ進めます(nが負の場合は戻します)。
他の2つ、std::next()関数とstd::prev()関数は、第1引数に受けたイテレーターをコピーして、第2引数だけ
- std::next()関数では進めて
- std::prev()関数では戻して
戻り値として返します。std::advance()関数と異なり、第1引数として渡したイテレーター自体は変更されません。
