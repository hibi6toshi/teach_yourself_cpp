# 12.4 タプル
**タプル**とは、複数お値の組みのことを指します。このとき、タプルを構成するここの値の型が異なっていても良い点が、配列やstd::vectorなどと異なります。

## 12.4.1 2つ組
std::pair<T, U> は2つの値の組を表現するための型で、<utility>ヘッダーで提供されています。2種類の値しか格納できないためタプルとしては機能が不足していますが、標準ライブラリの中でもさまざまな場所で使われている、基本的な型といえます。
std::pairは2つのメンバー変数firstとsecondを持ち、そのどちらもが公開メンバー変数となっています。

## 12.4.2 任意の個数の組
std::pairは2種類の値しか持てませんでしたが、（それ以上の）任意の数の値を持つことができるクラスとして、std::tupleが<typle>ヘッダーで提供されています。std::tupleは可変長テンプレートを使って作られているため、特に要素数に制限はありません。
しかし、要素にアクセスするには、std::pairのようにわかりやすいメンバー変数があるわけではないので、std::get()関数を使ってアクセスします。
```C++
template <std::size_t N, typename... T>
element-type& get(std::tuple<T...>& tuple);
```

std::get()関数の第1テンプレートパラメーターに、取得したい要素のインデックスを指定します。戻り値の方はその要素の型になるように作られています。

## 12.4.3 構造化束縛
値をタプルにまとめるにはタプルのコンストラクターを使えば良いのですが、タプルの各要素を手に入れるためにstd::get()関数を使うのは少々面倒です。
**構造化束縛**はタプル(std::pairとstd::tuple)を展開して個別の変数として扱えるようにする機能です。構造化束縛はタプルだけでなく、配列や簡単な構造体についても同じように個別の変数に展開できます。

```C++
auto [varialbe-name...] = tuple-object;
```

構造化束縛は常にautoもしくは、constや参照が付いたautoしか指定できません。子pれは常に型推論させることを意味しており、タプルを伴わない（初期化しない）構造化束縛はエラーとなります。

```C++
auto [a, b]; // エラー　何に推論すればいいか不明
```
ただのautoであればタプルの各要素をコピーしたものを変数として展開します。一方でauto&であれば、タプルの各要素への参照として展開します。
