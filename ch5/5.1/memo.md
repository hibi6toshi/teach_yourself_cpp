# 5.1 配列とポインター

## 5.1.1 ポインターへの暗黙変換
配列は、ポインター型への暗黙変換を行えます。
暗黙変換される時には先頭の要素へのポインターとして変換されます。

## 5.1.2 次のアドレス
配列をポインターに変換すると先頭のアドレスとなりましたが、戦闘以外の要素にアクセスするには、配列の時と同じく添え字演算子を使います。

添字演算子は直接任意の要素にアクセスしますが、ポインターのアドレスを使ってもアクセスできます。変数のアドレスは１足すと次の要素のアドレスを、１を引くと前の要素のアドレスを指します。

## 5.1.3 配列と引数
配列のコピーを作ることができないのは、引数であっても同じです。しかし関数の引数として配列を記述することは可能です。ただしその際、引数に記述された配列は配列ではなく、ポインターとして宣言されたものとして扱われます。そのため、次のプロトタイプ宣言はどちらも同じ意味となります。
```C++
void function(int array[5]); // OK
void function(int* array); // 上の宣言と同じ意味
```

ポインターと同じ意味となってしまうので、配列の長さが違っていても関数の呼び出しはできてしまうことに注意
```C++
void funtion(int array[5]);

int main() {
  int array[4] = {};

  function(array); // OK ポインターへの暗黙変換が行われる。
}
```

## 5.1.4 配列の型と別名
配列はポインターに暗黙的に変換できますが、配列自体はポインター型ではなく「配列の型」というものを持っています。ただし、配列へのポインター型や配列への参照型は、普通のポインター型や参照型の宣言とは表記方法が大きく異なるので注意が必要です。

```C++: 配列の型・ポインターと参照　
type-name[artrau-length] // 配列の型

type-name (*)[array-length] // 配列へのポインター型

type-name (*pointer-name)[array-length] = & array-name; // 配列へのポインターの宣言

type-name (&)[array-length] // 配列への参照型

type-name (& reference-name)[array-length] = array-name; // 配列への参照の宣言
```

配列へのポインターや参照はかっこがあり少々使いづらいので、必要となった場合には型に別名を与えると良い。
```C++
using int_array = int[5];

int_array array; // 長さ5のint型の配列

int_array* aptr = &array; // 長さ5のint型の配列への参照

using int_array_pointer = int (*)[5];

int_array_pointer ptr = &array; // 長さ5のint型の配列へのポインター

using int_array_reference = int (&)[5];

int_array_reference ref = array; // 長さ5のint型の配列への参照
```