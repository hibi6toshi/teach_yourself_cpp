# 5.4 newとdeleteの詳細　
実際のアプリケーションを開発するにあたって、基本的な動的確保だけでは機能として不足している部分があります。それは「割り当てたオブジェクトに初期値を与える機能」と「配列の動的確保の機能」です、

## 5.4.1 割り当てたオブジェクトに初期値を与える
new演算子に対してコンストラクターへの引数を渡すことにより、適切なコンストラクターを使ってオブジェクトを初期化することができます。
new演算子にコンストラクターへの引数を渡す構文は次のとおり。
```C++
variable = new type(arguments...);

variable = new type{arguments...};
```

使う括弧の違いは通常のコンストラクター呼び出しと全く同じです。 (つまり、{} の方は危険な変換ができないようになっています。)コンストラクターへの引数の数を増やしたい場合も、通常のコンストラクター呼び出しと同じようにカンマ区切りで好きな数にできます。

## 5.4.2 配列の動的確保
配列を動的確保する場合について、通常の配列はあらかじめプログラムに記載した長さしか確保することができませんが、動的確保を使うと実行時に好きな長さで確保することができます。
このため、寿命は関数スコープで問題ないとしても、いくつ必要になるか実行時までわからないという場合には動的確保を行う必要があります。

配列の動的確保はうまく扱わないとメモリーリークやバッファーオーバーランなどを簡単に引き起こせてしまうので、特別な理由がない限り標準ライブラリのコンテナクラスを使うことをお勧めします。

配列を動的確保するためのnew演算子とdelete演算子は、これまでのように1つだけ確保する場合とは若干異なる構文になります。
また、new演算子の戻り値の型とdelete演算子が受け取る変数の方は、1つだけのnew/delete演算子と全く同じポインターになるため、気づかず間違ってしまうことが多くあります。
```C++: 配列の動的確保
type* variable = new type [array-length];

type* variable = new type [array-length] { initial-values... };
```

```C++: 動的確保した配列のdelete
delete [] variable;
```

new演算子では、配列の時に出てきた[] を使って、配列と同様に必要な数を指定します。new演算子から返されるポイインターは動的確保した配列の先頭へのアドレスです。
一方、delete演算子では[]を書く必要はありますが配列の長さについては指定する必要はありますせん。
そのため、間違ってる通常のdelete演算子を使ってしまうミスが多くあります。
配列用のnew演算子を使った場合は、必ず配列用のdelete演算子を使わなければならないことに注意してください。


