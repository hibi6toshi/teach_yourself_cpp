# 5.2 オブジェクトの配列

##　5.2.1 オブジェクトの配列と初期化
C++ではクラスも組み込み方と同じように配列を作ることができます。組み込み型の配列では、初期値を渡さなければ初期化されず、一方配列の長さと同じ数だけ初期値を渡すことで、それぞれが初期化されました。
（関数形式の）**明示的な型変換**と呼ばれるコンストラクター呼び出しを行なってインスタンスを返す記法を使うことができます。
これは途中の変数を作ることなく、関数呼び出しの実引数に使うインスタンスを作ったりする際に使います。
関数形式の明示的な型変換
```C++
type-name(arguments...)

type-name{arguments...}
```

```C++
// 明示的な変換を使ってインスタンスを作り、関数の引数として渡す
void foo(A{{"name", 42}});
```
配列内の初期化する各要素について、この明示的な型変換を並べていくと、配列の各要素を目的通りに初期化できます。

クラスを配列にするときのちゅいてんですが、配列とはいえオブジェクトなのでもちろんデストラクターの呼び出しが必ずおこなわれます。
配列は危険な操作ができてしまうことが多いので、標準ライブラリが提供しているコンテナクラスを使ったほうが安全であり、便利です。


## 5.2.2 動的配列
配列はプログラムを書いたときに長さが決まっていて、プログラムの実行中にその長さを変えることはできません。このような配列を特に**固定長配列**と呼びます。
しかし、プログラムを書いた時に配列の長さが決まっていないということの方が実際は多くあります。
**std::vector**は固定長配列と同じように扱えますが、その長さは後から自由に変えることができます。このように長さが変わる配列を**動的配列**といいます。
std::vectorを使って動的配列を作るには次のようにします。
```C++
#include <vector> // <vector>ヘッダーをインクルードします。

class A {...};

std::vector<int> int_vector; // int型の動的配列
std::vector<A> A_vector; // クラスAの動的配列
```

<int> や <A> はテンプレート引数というものです。
テンプレート引数に好きな方をかくとその方用のstd::vector をコンパイラーが自動的に生成します。


動的配列は宣言しただけでは中身がからの配列となっています。
通常の配列の時と同じく、{}を使って初期値を与えることもできます。またsize()メンバー関数を使うと動的配列の現在の長さがわかります。
```C++
// size() メンバー関数
std::size_t size() const;
```
通常の配列ではできない、後から要素を追加や削除につてはいくつか種類がある。
ここでは、 「最後に追加する」操作をおこなうpush_back() と「最後を削除する」操作を行うpop_back()
```C++
void push_back(const T& value);

void pop_back();
```

push_back() メンバー関数の引数の型のTはテンプレート引数で渡した型と同じものとなります。
pop_back()メンバー関数は何も戻り値を返さないので、削除した要素が必要であればあらかじめコピーしておく必要があります。
