# プリプロセッサー
プリプロセッサーはソースコードをコンパイルする前に実行される前処理プログラムのこと

## 4.9.1 プリプロセッサー命令
**プリプロセッサー命令**は、どのような前処理を行う必要があるのかをプリプロセッサーへ指示するための特別な指示文です。
プリプロセッサー命令は**ハッシュ**で始まるさまざまな命令です。
ハッシュは必ず行頭に書かねばならず、空白のみがハッシュの前に挿入することを許されています。
なおハッシュとプリプロセっっさー命令の間には、空白を描くことが許されています。

```C++
// OK 行頭がハッシュで始まっている
#include <iostream>

// OK ハッシュまでの空白は無視される
  #include <iostream>

// OK ハッシュからプリプロセッサー命令の間の空白も無視される
#   include <iostream>

// OK ハッシュの前後両方に空白を挿入しても良い
  #  include <iostream>
```

## #include命令
#include はヘッダーファイルを読み込むプリプロセッサー命令です。何度も登場してきた `#include <iostream>` は、iostreamというヘッダーファイルを読み込ませる命令ということになります。
このときプリプロセッサーはすでに読み込んだかどうかを記録していないので、何度もインクルードすると重複してヘッダーファイルを読み込んでしまいます。

#include 命令には主に2つの種類があります。
```C++
#include <file-name>

#include "file-name"
```
一般的に標準ライブラリのような事前に提供されているものを使う場合には上の形式を、プロジェクトの中で用意したヘッダーファイルを読み込む場合にはしたの形式を使うことが多いです。

ヘッダーファイルの#includeは基本的にソースファイルの先頭で行うようにする。

## 4.9.2 マクロ
プリプロセサー命令には識別子を別の識別子に置き換える命令もあります。これを**マクロ**といいます。
プリプロセッサーは、マクロを見つけるとあらかじめ定義していた別のトークン列へとそのまま置き換え、ソースコードそのものを変更します。
トークンとは、ほとんどの場合識別子と同じ意味ですが、プリプロセッサはコンパイルとは違う処理なので呼び方が異なっています。
マクロを定義する構文は次のとおりです。
```C++
#define macro-name

#define macro-name macro-replacement
```
マクロが置き換える文字列は省略可能であり、その場合プリプロセッサーはその識別子をプログラムからただ単に取り除きます。

実際にコンパイラニー渡されるプログラムは、プリプロセッサーによるマクロの置き換えが起こった後のプログラムです。

マクロはプリプロセッサーで処理される機能です。そのためこの段階ではまだ名前空間やクラス、関数スコープといったプログラムの構造については認識されないまま処理が行われます。そのため、マクロの名前は簡単に他のマクロと衝突してしまうので、できるだけ他のマクロと重複しないように、長めの名前にするのが一般的です。

## マクロの定義を消す
マクロは一度定義すると、その後コンパイルが終わるまで有効になります。#includeで取り込まれた他のヘッダーファイルのマクロも、同様に全てが最後まで有効になります。
しかし、マクロがずっと有効になっていると意図しない置き換えが起きてしまう。
こういった場合のためにマクロ定義を消すプリプロセッサー命令があります。このプリプロセッサー命令の構文は以下の通りです。

```C++
#undef macro-name
```

この命令に達すると、指定したマクロの定義が消え、それ以降の識別子の置き換えは起こりません。
例えばヘッダーの中で一部処理を簡単にするためにマクロを定義したら、ヘッダーの最終で#undefをしておくと、そのマクロが不必要に残って他のプログラムに影響を与えるようなことがありません。

## 関数形式マクロ
マクロには、**関数形式マクロ**という、引数を与えて置き換える文字列を変更できるものがあります。
```C++
#define macro-name(macro-parameter-name, macro-parameter-name...)

#define macro-name(macro-parameter-name, macro-parameter-name...) macro-replacement
```
関数マクロも、置き換える文字列を省略することができます。

## 4.9.3 結合と展開
## \##演算子
マクロは展開中に指定されたトークン列に置き換えますが、常に空白で区切るので、そのままではトークンとトークンをつなげた新しいトークンを作ることはできません。
```C++
#define concatenate(left, right) left right
concatenate(foo, bar) // => 「foo bar」に置き換わる

#define concatenate(laft, right) liftright
concatenate(foo, bar) // => 「leftright」に置き換わる
// leftright に変わる。　foobarではない。　文字列的な扱いになってしまっている。
```

トークン列を結合したものに置き換えるには、**##演算子**を使います。##演算子はマクロ定義の中でのみ有効な演算子で、前後のトークンを結合したトークンに置き換えます。
```C++
#define concatenate(left, right) left ## right
concatenate(foo, bar) // => 「foobar」 に置き変わる
```

## #演算子
マクロはトークンを別のトークン列に置き換えますが、幕と定義の中に書かれた("" で囲まれた)文字列は置き換えの対象になりません。
```C++
#define stringize(value) "value"
stringize(hoge) // 「"value"」 に置き換わる
```

文字列の中もマクロの置き換え対象とならないので、そのままではマクロ展開した結果を文字列にすることができません。
マクロ展開でトークン列を文字列に置き換えたい場合には、**#演算子**を使います。#演算子の直後にあるトークン1つが文字列として展開されます。
```C++
#defie stringize(value) #value
stringize(hoge) // => 「"hoge"」 に置き換わる

// #演算子の直後のトークン、secondだけが文字列になる
#define complex_macro(first, second, third) first # second third
complex_macro(hoge, fuga, piyo) // => 「hoge "fuga" piyo」に置き換わる
